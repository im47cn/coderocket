#!/bin/bash

# é¢œè‰²å®šä¹‰
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# ä»ç¯å¢ƒå˜é‡è·å–é…ç½®
GITLAB_API_URL=${GITLAB_API_URL:-"https://gitlab.com/api/v4"}
GITLAB_PERSONAL_ACCESS_TOKEN=${GITLAB_PERSONAL_ACCESS_TOKEN:-""}

# å‡½æ•°ï¼šä» git remote è·å–é¡¹ç›®è·¯å¾„
get_project_path_from_remote() {
    local remote_name=${1:-"origin"}
    local remote_url=$(git config --get remote.$remote_name.url)
    local project_path=""

    if [[ $remote_url =~ git@.*:(.+)\.git ]]; then
        # SSH æ ¼å¼: git@gitlab.com:namespace/project.git
        project_path="${BASH_REMATCH[1]}"
    elif [[ $remote_url =~ https?://[^/]+/(.+)\.git ]]; then
        # HTTPS æ ¼å¼: https://gitlab.com/namespace/project.git
        project_path="${BASH_REMATCH[1]}"
    fi

    echo "$project_path"
}

# å‡½æ•°ï¼šæ£€æµ‹ GitLab remote
detect_gitlab_remote() {
    local remotes=$(git remote)
    local gitlab_remote=""

    # æ£€æŸ¥æ¯ä¸ª remote æ˜¯å¦æŒ‡å‘ GitLab
    for remote in $remotes; do
        local remote_url=$(git config --get remote.$remote.url)
        if [[ $remote_url =~ gitlab ]]; then
            gitlab_remote="$remote"
            break
        fi
    done

    echo "$gitlab_remote"
}

# å‡½æ•°ï¼šé€šè¿‡ API è·å–é¡¹ç›® ID
get_project_id_by_path() {
    local project_path=$1
    # URL ç¼–ç é¡¹ç›®è·¯å¾„
    local encoded_path=$(echo -n "$project_path" | python3 -c "import sys, urllib.parse; print(urllib.parse.quote(sys.stdin.read(), safe=''))")
    
    local response=$(curl -s --header "PRIVATE-TOKEN: $GITLAB_PERSONAL_ACCESS_TOKEN" \
        "$GITLAB_API_URL/projects/$encoded_path")
    
    local project_id=$(echo "$response" | python3 -c "
import sys, json
try:
    data = json.load(sys.stdin)
    print(data.get('id', ''))
except:
    print('')
")
    
    echo "$project_id"
}

# å‡½æ•°ï¼šä»ç¼“å­˜æ–‡ä»¶è¯»å–é¡¹ç›® ID
get_cached_project_id() {
    local cache_file=".git/gitlab-project-id"
    if [ -f "$cache_file" ]; then
        cat "$cache_file"
    else
        echo ""
    fi
}

# å‡½æ•°ï¼šç¼“å­˜é¡¹ç›® ID
cache_project_id() {
    local project_id=$1
    local cache_file=".git/gitlab-project-id"
    echo "$project_id" > "$cache_file"
}

# å‡½æ•°ï¼šè‡ªåŠ¨è·å–é¡¹ç›® ID
auto_get_project_id() {
    local project_id=""
    
    # 1. å°è¯•ä» CI ç¯å¢ƒå˜é‡è·å–
    if [ ! -z "$CI_PROJECT_ID" ]; then
        echo -e "${GREEN}âœ“ ä» CI ç¯å¢ƒå˜é‡è·å–é¡¹ç›® ID: $CI_PROJECT_ID${NC}" >&2
        echo "$CI_PROJECT_ID"
        return
    fi
    
    # 2. å°è¯•ä»ç¼“å­˜è·å–
    project_id=$(get_cached_project_id)
    if [ ! -z "$project_id" ]; then
        echo -e "${GREEN}âœ“ ä»ç¼“å­˜è·å–é¡¹ç›® ID: $project_id${NC}" >&2
        echo "$project_id"
        return
    fi
    
    # 3. å°è¯•ä» git remote è·å–
    echo -e "${YELLOW}â†’ æ­£åœ¨ä» Git remote è·å–é¡¹ç›®ä¿¡æ¯...${NC}" >&2

    # æ£€æµ‹ GitLab remote
    local gitlab_remote=$(detect_gitlab_remote)
    if [ -z "$gitlab_remote" ]; then
        echo -e "${RED}âœ— æœªæ‰¾åˆ° GitLab remote${NC}" >&2
        echo ""
        return
    fi

    echo -e "${YELLOW}â†’ ä½¿ç”¨ GitLab remote: $gitlab_remote${NC}" >&2
    local project_path=$(get_project_path_from_remote "$gitlab_remote")
    
    if [ ! -z "$project_path" ]; then
        echo -e "${YELLOW}â†’ é¡¹ç›®è·¯å¾„: $project_path${NC}" >&2
        
        # é€šè¿‡ API è·å–é¡¹ç›® ID
        if [ ! -z "$GITLAB_PERSONAL_ACCESS_TOKEN" ]; then
            project_id=$(get_project_id_by_path "$project_path")
            
            if [ ! -z "$project_id" ]; then
                echo -e "${GREEN}âœ“ é€šè¿‡ API è·å–é¡¹ç›® ID: $project_id${NC}" >&2
                # ç¼“å­˜é¡¹ç›® ID
                cache_project_id "$project_id"
                echo "$project_id"
                return
            fi
        else
            echo -e "${RED}âœ— æœªè®¾ç½® GITLAB_PERSONAL_ACCESS_TOKENï¼Œæ— æ³•è°ƒç”¨ API${NC}" >&2
        fi
    fi
    
    # 4. å°è¯•ä»æœ¬åœ°é…ç½®æ–‡ä»¶è¯»å–
    if [ -f ".gitlab-ci.yml" ]; then
        project_id=$(grep -E "PROJECT_ID:" .gitlab-ci.yml | awk '{print $2}' | tr -d '"')
        if [ ! -z "$project_id" ]; then
            echo -e "${GREEN}âœ“ ä» .gitlab-ci.yml è·å–é¡¹ç›® ID: $project_id${NC}" >&2
            cache_project_id "$project_id"
            echo "$project_id"
            return
        fi
    fi
    
    echo ""
}

# å‡½æ•°ï¼šäº¤äº’å¼è·å–é¡¹ç›® ID
interactive_get_project_id() {
    local gitlab_remote=$(detect_gitlab_remote)
    local project_path=$(get_project_path_from_remote "$gitlab_remote")
    
    echo -e "${YELLOW}æ— æ³•è‡ªåŠ¨è·å–é¡¹ç›® ID${NC}"
    echo "é¡¹ç›®è·¯å¾„: $project_path"
    echo ""
    echo "è¯·é€šè¿‡ä»¥ä¸‹æ–¹å¼ä¹‹ä¸€è·å–é¡¹ç›® IDï¼š"
    echo "1. è®¿é—®é¡¹ç›®é¡µé¢: $GITLAB_API_URL/$project_path"
    echo "2. åœ¨é¡¹ç›®é¡µé¢æŸ¥çœ‹ Settings > General > Project ID"
    echo ""
    read -p "è¯·è¾“å…¥é¡¹ç›® ID: " project_id </dev/tty
    
    if [ ! -z "$project_id" ]; then
        cache_project_id "$project_id"
        echo "$project_id"
    else
        echo ""
    fi
}

# å‡½æ•°ï¼šæ£€æµ‹åŸºç¡€åˆ†æ”¯
detect_base_branch() {
    local current_branch=$1
    local gitlab_remote=$2

    # å¸¸è§çš„åŸºç¡€åˆ†æ”¯åˆ—è¡¨ï¼ŒæŒ‰ä¼˜å…ˆçº§æ’åº
    local base_branches=("develop" "main" "master" "dev")

    for base_branch in "${base_branches[@]}"; do
        # æ£€æŸ¥è¿œç¨‹åˆ†æ”¯æ˜¯å¦å­˜åœ¨
        if git show-ref --verify --quiet "refs/remotes/$gitlab_remote/$base_branch"; then
            # æ£€æŸ¥å½“å‰åˆ†æ”¯æ˜¯å¦ä»è¿™ä¸ªåŸºç¡€åˆ†æ”¯åˆ†å‰å‡ºæ¥
            local merge_base=$(git merge-base "$current_branch" "$gitlab_remote/$base_branch" 2>/dev/null)
            if [ ! -z "$merge_base" ]; then
                echo "$base_branch"
                return
            fi
        fi
    done

    # å¦‚æœæ²¡æœ‰æ‰¾åˆ°ï¼Œé»˜è®¤ä½¿ç”¨ main
    echo "main"
}

# å‡½æ•°ï¼šè·å–åˆ†æ”¯çš„æ‰€æœ‰æäº¤ä¿¡æ¯
get_branch_commits() {
    local source_branch=$1
    local base_branch=$2
    local gitlab_remote=$3

    # è·å–ä»åŸºç¡€åˆ†æ”¯åˆ°å½“å‰åˆ†æ”¯çš„æ‰€æœ‰æäº¤
    local commits=$(git log --reverse --pretty=format:"%h|%s|%an|%ad" --date=short "$gitlab_remote/$base_branch..$source_branch" 2>/dev/null)

    if [ -z "$commits" ]; then
        # å¦‚æœæ²¡æœ‰æ‰¾åˆ°æäº¤å·®å¼‚ï¼Œè·å–æœ€è¿‘çš„å‡ ä¸ªæäº¤
        commits=$(git log --reverse --pretty=format:"%h|%s|%an|%ad" --date=short -n 5 "$source_branch")
    fi

    echo "$commits"
}

# å‡½æ•°ï¼šä½¿ç”¨ Gemini ç”Ÿæˆæ™ºèƒ½ MR æ ‡é¢˜
generate_mr_title_with_gemini() {
    local source_branch=$1
    local base_branch=$2
    local gitlab_remote=$3

    # è·å–æ‰€æœ‰ç›¸å…³æäº¤
    local commits=$(get_branch_commits "$source_branch" "$base_branch" "$gitlab_remote")
    local commit_count=$(echo "$commits" | wc -l | tr -d ' ')

    if [ "$commit_count" -eq 1 ]; then
        # å•ä¸ªæäº¤ï¼Œç›´æ¥ä½¿ç”¨æäº¤ä¿¡æ¯
        echo "$commits" | cut -d'|' -f2
        return
    fi

    # æ£€æŸ¥ gemini å‘½ä»¤æ˜¯å¦å¯ç”¨
    if ! command -v gemini &> /dev/null; then
        echo "ğŸ”€ Update: $source_branch"
        return
    fi

    # å‡†å¤‡æäº¤ä¿¡æ¯ç»™ Gemini
    local commit_list=""
    while IFS='|' read -r hash subject author date; do
        if [ ! -z "$hash" ]; then
            commit_list+="- $subject\n"
        fi
    done <<< "$commits"

    # ä½¿ç”¨ Gemini ç”Ÿæˆæ ‡é¢˜
    local prompt="è¯·æ ¹æ®ä»¥ä¸‹ Git æäº¤è®°å½•ï¼Œç”Ÿæˆä¸€ä¸ªç®€æ´æœ‰æ„ä¹‰çš„ MR æ ‡é¢˜ã€‚è¦æ±‚ï¼š
1. æ ‡é¢˜åº”è¯¥æ¦‚æ‹¬ä¸»è¦å˜æ›´å†…å®¹
2. ä½¿ç”¨ä¸­æ–‡
3. ä¸è¶…è¿‡ 50 ä¸ªå­—ç¬¦
4. ä¸éœ€è¦åŒ…å«æäº¤æ•°é‡
5. å¯ä»¥ä½¿ç”¨é€‚å½“çš„ emoji å›¾æ ‡ï¼ˆå¦‚ âœ¨ ğŸ› ğŸ“ â™»ï¸ ç­‰ï¼‰

æäº¤è®°å½•ï¼š
$commit_list

è¯·ç›´æ¥è¿”å›æ ‡é¢˜ï¼Œä¸è¦åŒ…å«å…¶ä»–è§£é‡Šï¼š"

    local title=$(echo "$prompt" | gemini -y 2>/dev/null | head -1 | sed 's/^[[:space:]]*//' | sed 's/[[:space:]]*$//')

    # å¦‚æœ Gemini è°ƒç”¨å¤±è´¥ï¼Œä½¿ç”¨å¤‡ç”¨æ–¹æ¡ˆ
    if [ -z "$title" ] || [ ${#title} -gt 100 ]; then
        # æ ¹æ®åˆ†æ”¯åç§°ç”Ÿæˆå¤‡ç”¨æ ‡é¢˜
        if [[ $source_branch =~ ^feature/.* ]]; then
            title="âœ¨ Feature: ${source_branch#feature/}"
        elif [[ $source_branch =~ ^fix/.* ]]; then
            title="ğŸ› Fix: ${source_branch#fix/}"
        elif [[ $source_branch =~ ^hotfix/.* ]]; then
            title="ğŸš‘ Hotfix: ${source_branch#hotfix/}"
        else
            title="ğŸ”€ Update: $source_branch"
        fi
    fi

    echo "$title"
}

# å‡½æ•°ï¼šä½¿ç”¨ Gemini ç”Ÿæˆæ™ºèƒ½ MR æè¿°
generate_mr_description_with_gemini() {
    local source_branch=$1
    local base_branch=$2
    local gitlab_remote=$3

    # è·å–æ‰€æœ‰ç›¸å…³æäº¤
    local commits=$(get_branch_commits "$source_branch" "$base_branch" "$gitlab_remote")
    local commit_count=$(echo "$commits" | wc -l | tr -d ' ')

    # å¦‚æœåªæœ‰ä¸€ä¸ªæäº¤ï¼Œä½¿ç”¨è¯¥æäº¤çš„è¯¦ç»†ä¿¡æ¯
    if [ "$commit_count" -eq 1 ]; then
        local commit_msg=$(git log -1 --pretty=%B)
        local description="## ğŸ“‹ å˜æ›´æ¦‚è¿°\n\n$commit_msg\n\n"
        description+="## âœ… æ£€æŸ¥æ¸…å•\n\n"
        description+="- [ ] ä»£ç å·²ç»è¿‡è‡ªæµ‹\n"
        description+="- [ ] ç›¸å…³æ–‡æ¡£å·²æ›´æ–°\n"
        description+="- [ ] æµ‹è¯•ç”¨ä¾‹å·²æ·»åŠ /æ›´æ–°\n"
        description+="- [ ] æ— æ˜æ˜¾çš„æ€§èƒ½å½±å“\n"
        description+="- [ ] ç¬¦åˆä»£ç è§„èŒƒ\n\n"
        echo -e "$description"
        return
    fi

    # æ£€æŸ¥ gemini å‘½ä»¤æ˜¯å¦å¯ç”¨
    if ! command -v gemini &> /dev/null; then
        # å¤‡ç”¨æ–¹æ¡ˆï¼šç®€å•åˆ—å‡ºæäº¤
        local description="## ğŸ“‹ å˜æ›´æ¦‚è¿°\n\næœ¬æ¬¡åˆå¹¶åŒ…å« **$commit_count** ä¸ªæäº¤ï¼š\n\n"
        while IFS='|' read -r hash subject author date; do
            if [ ! -z "$hash" ]; then
                description+="- $subject\n"
            fi
        done <<< "$commits"
        description+="\n## âœ… æ£€æŸ¥æ¸…å•\n\n"
        description+="- [ ] ä»£ç å·²ç»è¿‡è‡ªæµ‹\n"
        description+="- [ ] ç›¸å…³æ–‡æ¡£å·²æ›´æ–°\n"
        description+="- [ ] æµ‹è¯•ç”¨ä¾‹å·²æ·»åŠ /æ›´æ–°\n"
        description+="- [ ] æ— æ˜æ˜¾çš„æ€§èƒ½å½±å“\n"
        description+="- [ ] ç¬¦åˆä»£ç è§„èŒƒ\n\n"
        echo -e "$description"
        return
    fi

    # å‡†å¤‡æäº¤ä¿¡æ¯ç»™ Gemini
    local commit_list=""
    while IFS='|' read -r hash subject author date; do
        if [ ! -z "$hash" ]; then
            commit_list+="- $subject ($date)\n"
        fi
    done <<< "$commits"

    # ä½¿ç”¨ Gemini ç”Ÿæˆæè¿°
    local prompt="è¯·æ ¹æ®ä»¥ä¸‹ Git æäº¤è®°å½•ï¼Œç”Ÿæˆä¸€ä¸ªä¸“ä¸šçš„ MR æè¿°ã€‚è¦æ±‚ï¼š
1. æ€»ç»“ä¸»è¦å˜æ›´å†…å®¹å’Œç›®æ ‡
2. ä½¿ç”¨ä¸­æ–‡
3. ç»“æ„æ¸…æ™°ï¼Œé‡ç‚¹çªå‡º
4. ä¸è¦ç®€å•ç½—åˆ—æäº¤ï¼Œè€Œæ˜¯è¦æ¦‚æ‹¬å’Œæ€»ç»“
5. æè¿°åº”è¯¥è®©å®¡æŸ¥è€…å¿«é€Ÿç†è§£è¿™æ¬¡å˜æ›´çš„ç›®çš„å’Œå½±å“

æäº¤è®°å½•ï¼š
$commit_list

è¯·æŒ‰ä»¥ä¸‹æ ¼å¼è¿”å›ï¼š
## ğŸ“‹ å˜æ›´æ¦‚è¿°

[åœ¨è¿™é‡Œå†™å˜æ›´çš„æ€»ç»“å’Œç›®æ ‡]

## ğŸ”§ ä¸»è¦æ”¹è¿›

[åœ¨è¿™é‡Œåˆ—å‡ºä¸»è¦çš„æ”¹è¿›ç‚¹ï¼Œç”¨ç®€æ´çš„è¦ç‚¹å½¢å¼]"

    local ai_description=$(echo "$prompt" | gemini -y 2>/dev/null)

    # å¦‚æœ Gemini è°ƒç”¨å¤±è´¥ï¼Œä½¿ç”¨å¤‡ç”¨æ–¹æ¡ˆ
    if [ -z "$ai_description" ]; then
        local description="## ğŸ“‹ å˜æ›´æ¦‚è¿°\n\næœ¬æ¬¡åˆå¹¶åŒ…å« **$commit_count** ä¸ªæäº¤ï¼Œä¸»è¦å˜æ›´å¦‚ä¸‹ï¼š\n\n"
        while IFS='|' read -r hash subject author date; do
            if [ ! -z "$hash" ]; then
                description+="- $subject\n"
            fi
        done <<< "$commits"
        ai_description="$description"
    fi

    # æ·»åŠ æ£€æŸ¥æ¸…å•
    local final_description="$ai_description\n\n## âœ… æ£€æŸ¥æ¸…å•\n\n"
    final_description+="- [ ] ä»£ç å·²ç»è¿‡è‡ªæµ‹\n"
    final_description+="- [ ] ç›¸å…³æ–‡æ¡£å·²æ›´æ–°\n"
    final_description+="- [ ] æµ‹è¯•ç”¨ä¾‹å·²æ·»åŠ /æ›´æ–°\n"
    final_description+="- [ ] æ— æ˜æ˜¾çš„æ€§èƒ½å½±å“\n"
    final_description+="- [ ] ç¬¦åˆä»£ç è§„èŒƒ\n\n"

    echo -e "$final_description"
}

# å‡½æ•°ï¼šåˆ›å»º MR
create_merge_request() {
    local project_id=$1
    local source_branch=$2
    local target_branch=${3:-"main"}

    # æ£€æµ‹ GitLab remote
    local gitlab_remote=$(detect_gitlab_remote)

    # è‡ªåŠ¨æ£€æµ‹åŸºç¡€åˆ†æ”¯
    if [ "$target_branch" = "main" ]; then
        target_branch=$(detect_base_branch "$source_branch" "$gitlab_remote")
        echo -e "${YELLOW}â†’ è‡ªåŠ¨æ£€æµ‹ç›®æ ‡åˆ†æ”¯: $target_branch${NC}"
    fi

    # æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨ MR
    local existing_mr=$(curl -s --header "PRIVATE-TOKEN: $GITLAB_PERSONAL_ACCESS_TOKEN" \
        "$GITLAB_API_URL/projects/$project_id/merge_requests?source_branch=$source_branch&target_branch=$target_branch&state=opened" \
        | python3 -c "import sys, json; print(len(json.load(sys.stdin)))")

    if [ "$existing_mr" -gt 0 ]; then
        echo -e "${YELLOW}âš  MR å·²å­˜åœ¨${NC}"
        return
    fi

    # ç”Ÿæˆæ™ºèƒ½ MR æ ‡é¢˜å’Œæè¿°
    echo -e "${YELLOW}â†’ ä½¿ç”¨ Gemini ç”Ÿæˆ MR æ ‡é¢˜å’Œæè¿°...${NC}"
    local mr_title=$(generate_mr_title_with_gemini "$source_branch" "$target_branch" "$gitlab_remote")
    local mr_description=$(generate_mr_description_with_gemini "$source_branch" "$target_branch" "$gitlab_remote")
    
    # åˆ›å»º MR
    echo -e "${YELLOW}â†’ åˆ›å»º MR: $mr_title${NC}"

    # è½¬ä¹‰ JSON å­—ç¬¦ä¸²
    local escaped_title=$(echo "$mr_title" | python3 -c "import sys, json; print(json.dumps(sys.stdin.read().strip()))")
    local escaped_description=$(echo "$mr_description" | python3 -c "import sys, json; print(json.dumps(sys.stdin.read().strip()))")

    local response=$(curl -s -X POST --header "PRIVATE-TOKEN: $GITLAB_PERSONAL_ACCESS_TOKEN" \
        --header "Content-Type: application/json" \
        --data "{
            \"source_branch\": \"$source_branch\",
            \"target_branch\": \"$target_branch\",
            \"title\": $escaped_title,
            \"description\": $escaped_description,
            \"remove_source_branch\": true
        }" \
        "$GITLAB_API_URL/projects/$project_id/merge_requests")
    
    local mr_url=$(echo "$response" | python3 -c "
import sys, json
try:
    data = json.load(sys.stdin)
    print(data.get('web_url', ''))
except:
    print('')
")
    
    if [ ! -z "$mr_url" ]; then
        echo -e "${GREEN}âœ“ MR åˆ›å»ºæˆåŠŸ: $mr_url${NC}"
    else
        echo -e "${RED}âœ— MR åˆ›å»ºå¤±è´¥${NC}"
        echo -e "${YELLOW}API å“åº”:${NC}"
        echo "$response" | python3 -c "
import sys, json
try:
    data = json.load(sys.stdin)
    if 'message' in data:
        print('é”™è¯¯ä¿¡æ¯:', data['message'])
    if 'error' in data:
        print('é”™è¯¯è¯¦æƒ…:', data['error'])
    if 'errors' in data:
        print('éªŒè¯é”™è¯¯:', data['errors'])
    print('å®Œæ•´å“åº”:', json.dumps(data, indent=2, ensure_ascii=False))
except:
    print('åŸå§‹å“åº”:', sys.stdin.read())
"
    fi
}

# ä¸»æµç¨‹
main() {
    # è¯»å–å¹¶ä¸¢å¼ƒ Git ä¼ é€’çš„æ ‡å‡†è¾“å…¥ï¼ˆæ¨é€å¼•ç”¨ä¿¡æ¯ï¼‰
    # ä½¿ç”¨è¶…æ—¶è¯»å–é¿å…é˜»å¡ï¼Œå¦‚æœæ²¡æœ‰è¾“å…¥åˆ™ç»§ç»­
    while IFS= read -r -t 0.1 line 2>/dev/null; do
        # ä¸¢å¼ƒ Git ä¼ é€’çš„å¼•ç”¨ä¿¡æ¯
        :
    done

    echo -e "${GREEN}=== GitLab MR è‡ªåŠ¨åˆ›å»º ===${NC}"

    # è·å–å½“å‰åˆ†æ”¯
    local current_branch=$(git branch --show-current)

    # æ£€æŸ¥æ˜¯å¦ä¸ºä¸»åˆ†æ”¯
    if [[ "$current_branch" =~ ^(main|master|develop)$ ]]; then
        echo -e "${YELLOW}å½“å‰åœ¨ä¸»åˆ†æ”¯ï¼Œè·³è¿‡ MR åˆ›å»º${NC}"
        exit 0
    fi

    # æ£€æŸ¥ GITLAB_PERSONAL_ACCESS_TOKEN
    if [ -z "$GITLAB_PERSONAL_ACCESS_TOKEN" ]; then
        echo -e "${RED}âœ— æœªè®¾ç½® GITLAB_PERSONAL_ACCESS_TOKEN ç¯å¢ƒå˜é‡${NC}"
        echo "è¯·è®¾ç½®: export GITLAB_PERSONAL_ACCESS_TOKEN='your-token'"
        exit 1
    fi

    # è‡ªåŠ¨è·å–é¡¹ç›® ID
    local project_id=$(auto_get_project_id)

    # å¦‚æœè‡ªåŠ¨è·å–å¤±è´¥ï¼Œå°è¯•äº¤äº’å¼è·å–
    if [ -z "$project_id" ]; then
        project_id=$(interactive_get_project_id)
    fi

    if [ -z "$project_id" ]; then
        echo -e "${RED}âœ— æ— æ³•è·å–é¡¹ç›® ID${NC}"
        exit 1
    fi

    echo -e "${GREEN}âœ“ é¡¹ç›® ID: $project_id${NC}"

    # è¯¢é—®æ˜¯å¦åˆ›å»º MR
    read -p "æ˜¯å¦åˆ›å»º MRï¼Ÿ(y/n) " -n 1 -r </dev/tty
    echo

    if [[ $REPLY =~ ^[Yy]$ ]]; then
        create_merge_request "$project_id" "$current_branch"
    fi
}

# æ‰§è¡Œä¸»æµç¨‹
main